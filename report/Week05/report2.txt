この.txtファイルのみでの提出です。
問1/2

let x = read_int () in
let y = (if x <= 0 then f 1 else 2) in
let z = (if y <= 3 then x - 4 else g 5) in
x - y - z

にsave/restoreを挿入すると、

let x = read_int () in
let y = save(x);(if x <= 0 then f 1 else 2) in
let z = save(y);restore(x);(if y <= 3 then x - 4 else g 5) in
restore(y);restore(x);x - y - z

となる。関数呼び出しが起こる可能性のある前に、生きている変数をsaveしている。
さらに、関数呼び出しの可能性の後にはrestoreする。

どうせ退避をするなら、定義の直後にした方がより良いため、下がより良い例である。
let x = read_int ();save(x) in
(let y = (if x <= 0 then f 1 else 2));save(y) in
let z = restore(x);(if y <= 3 then x - 4 else g 5) in
restore(y);restore(x);x - y - z

問2/2
以下のアッカーマン関数を考察する
let rec ack x y =
  if x=0 then
    y+1
  else if y=0 then
    ack (x-1) 1
  else
    ack (x-1) (ack x (y-1))

まず、手でK正規化すると、下のようになる。

let rec ack x y =
  if x=0 then
    let a = y + 1 in
      a
  else if y=0 then
    let b = x - 1 in
    let c = y - 1 in
      ack b one
  else
    let d = x - 1 in
    let e = y - 1 in
    let f = ack x d in
      ack c e
・レジスタはすべてcaller saveとする
・レジスタR0~R1があるとする、関数の引数はR0から順に、返り値はR0に入れることとする

--悪い割当--
let rec ack R0 R1 =
  if R0 = 0 then
    save(y);(* y->R1 *)
    let R1 = R1 + 1 in
      R1 (* return *)
  else if R1=0 then
    save(x);(* x->R0 *)
    let R0 = R0 - 1 in
    save(y);(* y->R1 *)
    let R1 = R1 + 1 in
      save(b);(* b->R0 *)
      save(one);(* one->R1 *)
      ack R0 1 (* return *)
  else
    save(x);(* x->R0 *)
    let R0 = R0 - 1 in
    save(y);(* y->R1 *)
    let R1 = R1 - 1 in
    save(c);(* c->R0 *)
    save(d);(* d->R1 *)
    restore(x);(* x->R0 *)
    ack R0 R1;
    let R1 = R0 in
      restore(c);(* c->R0 *)
      ack R0 R1 (* return *)

--良い割当--

let rec ack R0 R1 =
  if R0=0 then
    let R1 = R1 + 1 in
      R1
  else if R1=0 then
    let R0 = R0 - 1 in
      ack R0 1
  else
    let c = x - 1 in
    let d = y - 1 in
    let e = ack x d in
      ack c e

(* レジスタR0~R1があるとする、関数の引数はR0から順に、返り値はR0に入れることとする *)

(* 良い割当(退避はxのみで、できるだけ少ない回数) *)
let ack R0 R1 =
  if R0=0 then
    R0=R1+1 (* ; return *)
  else if R1=0 then
    let R0=R0-1 in
    (*call*) ack R0 R1 (* ; return *)
  else
    store_x(R0) ;
    let R1=R1-1 in
    (*call*) ack R0 R1 ;
    let R1=R0 in
    let R0=restore_x in
    let R0=R0-1 in
    (*call*) ack R0 R1 (* ; reutrn *)

(* 悪い割当(生存解析をせずにすべてストアする、同じ変数は同じレジスタにリストアする) *)
let ack R0 R1 =
  if R0=0 then
    store_x(R0) ;
    R0=R1+1 (* ; return *)
  else if R1=0 then
    store_x(R0) ;
    let R0=R0-1 in
    store_y(R1) ;
    (*call*) ack R0 R1 (* ; return *)
  else
    store_y(R1) ;
    let R1=R1-1 in
    store_x(R0) ;
    (*call*) ack R0 R1 ;
    let R1=R0 in
    let R0=restore_x in
    let R0=R0-1 in
    (*call*) ack R0 R1 (* ; return *)
----------問１----------
q1.mlに書きました。(スライドを真似した擬似コードです)
let y = ... を計算する時にはfの呼び出しがあるので、xのstoreが必要である。
let z = ... を計算するときにはgの呼び出しがあるのでyのstoreが必要である(xはすでにstore済)また変数xのリストアが必要である。
x-y-zの計算にはx,yのリストアが必要である。


----------問２----------

q2.mlに書きました。
悪い割当ではR0を上書きするときはxをストアして、R1を上書きするときはyをストア、また関数を呼ぶときは両方をstoreするようになっています。
良い割当ではstoreが必要なのは
ack( x-1 , ack( x , y ))を計算するときにxをstoreする１回のみになりました。
